import { walkVscode } from './walk-vscode';
import { promises as fs } from 'fs';
import * as path from 'path';
import * as ts from 'typescript';
import * as log from 'signale';
import * as wordwrap from 'wordwrap';
import { pascalCase } from 'pascal-case';
import { formatCode, packageDir } from './tool';

// See https://github.com/microsoft/vscode/blob/67cfd21b80752b134416ec517e0efd85bc8e86d2/src/vs/workbench/contrib/webview/common/themeing.ts#L50
// for how this stuff is generated in VS Code.

const prefix = `/** AUTOGENERATED: run 'npm run codegen' to update */
export const enum Color {
  /**
   * VS Code UI font family.
   */
  FontFamily = 'font-family',

  /**
   * VS Code UI font weight.
   */
  FontWeight = 'font-weight',

  /**
   * VS Code UI font size.
   */
  FontSize = 'font-size',

  /**
   * VS Code Editor font family.
   */
  EditorFontFamily = 'editor-font-family',

  /**
   * VS Code Editor font weight.
   */
  EditorFontWeight = 'editor-font-weight',

  /**
   * VS Code Editor font size.
   */
  EditorFontSize = 'editor-font-size',
`;

(async () => {
  let code = prefix;
  let count = 0;
  const seen = new Set<string>();

  const addDescription = (description: string) => {
    const comment = wordwrap(80 - 5)(description)
      .split('\n')
      .join('\n  * ');
    code += `/**\n * ${comment}\n */\n`;
  };

  const extract = (node: ts.Node): boolean => {
    if (
      !ts.isCallExpression(node) ||
      !ts.isIdentifier(node.expression) ||
      node.expression.text !== 'registerColor'
    ) {
      return false;
    }

    const [name, , descriptionCall] = node.arguments;
    if (!ts.isStringLiteral(name)) {
      log.warn(`Line did not have string literal name: ${node.getText()}`);
      return false;
    }

    if (seen.has(name.text)) {
      return true;
    }

    seen.add(name.text);

    if (ts.isStringLiteralLike(descriptionCall)) {
      addDescription(descriptionCall.text);
    } else if (
      ts.isCallExpression(descriptionCall) &&
      ts.isStringLiteralLike(descriptionCall.arguments[1])
    ) {
      // nls.localize(...)
      addDescription((descriptionCall.arguments[1] as ts.StringLiteralLike).text);
    } else {
      log.warn(`Could not get description for: ${node.getText()}`);
    }

    code += pascalCase(name.text) + ` = ${JSON.stringify(name.text.replace('.', '-'))},\n`;
    count++;
    return true;
  };

  await walkVscode(process.argv[2], (file) => {
    const traverse = (node: ts.Node) => {
      if (!extract(node)) {
        ts.forEachChild(node, traverse);
      }
    };

    traverse(file);
  });

  code += '}';

  await fs.writeFile(path.join(packageDir, 'src/pkg/colors.ts'), formatCode(code));
  log.success(`Discovered and generated code for ${count} colors`);
})();
